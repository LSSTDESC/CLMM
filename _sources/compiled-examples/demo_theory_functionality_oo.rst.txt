Model WL Profiles (Object Oriented)
===================================

Notebook for generating an example galaxy cluster model.
--------------------------------------------------------

This notebook goes through the steps to generate model data for galaxy
cluster weak lensing observables. In particular, we define a galaxy
cluster model that follows and NFW distribution and generate various
profiles for the model (mass density, convergence, shear, etc.), which
we plot. Note, a full pipeline to measure a galaxy cluster weak lensing
mass requires fitting the observed (or mock) data to a model. In this
notebook we use the OO interface to theory.

.. code:: ipython3

    import warnings
    warnings.filterwarnings("ignore", message='.*(!).*')


.. code:: ipython3

    import numpy as np
    import matplotlib.pyplot as plt
    %matplotlib inline

Imports specific to clmm

.. code:: ipython3

    import os
    
    os.environ['CLMM_MODELING_BACKEND'] = 'ccl' # here you may choose ccl, nc (NumCosmo) or ct (cluster_toolkit)
    
    import clmm
    from clmm import Cosmology

Make sure we know which version weâ€™re using

.. code:: ipython3

    clmm.__version__




.. parsed-literal::

    '1.5.3'



Define a cosmology using astropy

.. code:: ipython3

    cosmo = Cosmology(H0=70.0, Omega_dm0=0.27-0.045, Omega_b0=0.045, Omega_k0=0.0)

Define the galaxy cluster model. Here, we choose parameters that
describe the galaxy cluster model, including the mass definition,
concentration, and mass distribution. For the mass distribution, we
choose a distribution that follows an NFW profile.

.. code:: ipython3

    moo = clmm.Modeling(massdef='mean', delta_mdef=200, halo_profile_model='nfw')
    
    moo.set_cosmo(cosmo)
    moo.set_concentration(4)
    moo.set_mass(1.e15)
    
    z_cl = 1.
    
    #source properties
    z_source = 2. #all sources in the same plane
    z_distrib_func = clmm.z_distributions.chang2013 #sources redshift following a distribution
    alpha = [2, -0.5] 

Quick test of all theory functionality

.. code:: ipython3

    r3d = np.logspace(-2, 2, 100)
    rho = moo.eval_3d_density(r3d, z_cl)
    Sigma = moo.eval_surface_density(r3d, z_cl)
    DeltaSigma = moo.eval_excess_surface_density(r3d, z_cl)
    Sigmac = moo.eval_critical_surface_density(z_cl, z_source)
    gammat = moo.eval_tangential_shear(r3d, z_cl, z_source)
    kappa = moo.eval_convergence(r3d, z_cl, z_source)
    
    gt = moo.eval_reduced_tangential_shear(r3d, z_cl, z_source)
    #Lensing quantities assuming sources follow a given redshift distribution.
    gt_z = moo.eval_reduced_tangential_shear(r3d, z_cl, z_distrib_func, z_src_info='distribution',
                                            approx='order2')
    
    mu = moo.eval_magnification(r3d, z_cl, z_source)
    mu_bias = moo.eval_magnification_bias(r3d, z_cl, z_source, alpha)


.. parsed-literal::

    /global/homes/a/aguena/.local/cori/3.9-anaconda-2021.11/lib/python3.11/site-packages/clmm-1.5.3-py3.11.egg/clmm/theory/generic.py:72: UserWarning: Magnification is negative for certain radii,                     returning nan for magnification bias in this case.
    /global/homes/a/aguena/.local/cori/3.9-anaconda-2021.11/lib/python3.11/site-packages/clmm-1.5.3-py3.11.egg/clmm/theory/generic.py:74: RuntimeWarning: invalid value encountered in power


Plot the predicted profiles

.. code:: ipython3

    def plot_profile(r, profile_vals, profile_label='rho', label = ''):
        plt.loglog(r, profile_vals, label=label)
        plt.xlabel('r [Mpc]', fontsize='xx-large')
        plt.ylabel(profile_label, fontsize='xx-large')

.. code:: ipython3

    plot_profile(r3d, rho, '$\\rho_{\\rm 3d}$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_16_0.png


.. code:: ipython3

    plot_profile(r3d, Sigma, '$\\Sigma_{\\rm 2d}$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_17_0.png


.. code:: ipython3

    plot_profile(r3d, DeltaSigma, '$\\Delta\\Sigma_{\\rm 2d}$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_18_0.png


.. code:: ipython3

    plot_profile(r3d, kappa, '$\\kappa$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_19_0.png


.. code:: ipython3

    plot_profile(r3d, gammat, '$\\gamma_t$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_20_0.png


.. code:: ipython3

    plot_profile(r3d, gt, '$g_t$', label = 'single plane')
    plot_profile(r3d, gt_z, '$g_t$', label = 'redshift distribution')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_21_0.png


.. code:: ipython3

    plot_profile(r3d, mu, '$\mu$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_22_0.png


.. code:: ipython3

    plot_profile(r3d, mu_bias[0]-1, profile_label = '$\delta_{\mu}$', label = '$\\alpha$ =' + str(alpha[0]))
    plot_profile(r3d, mu_bias[1]-1, '$\delta_{\mu}$', label = '$\\alpha$ =' + str(alpha[1]))
    
    plt.legend(fontsize='xx-large')
    plt.yscale('linear')
    plt.grid()
    
    plt.ylim(-3,5)




.. parsed-literal::

    (-3.0, 5.0)




.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_23_1.png


.. code:: ipython3

    # The 2-halo term excess surface density is currently only implemented for the CCL and NC backends
    # An error will be raised if using the CT backend instead
    
    DeltaSigma_2h = moo.eval_excess_surface_density_2h(r3d, z_cl, halobias=0.3)
    plot_profile(r3d, DeltaSigma_2h, '$\\Delta\\Sigma_{\\rm 2h}$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_24_0.png


.. code:: ipython3

    # The 2-halo term excess surface density is currently only implemented for the CCL and NC backends
    # An error will be raised if using the CT backend instead
    
    Sigma_2h = moo.eval_surface_density_2h(r3d, z_cl, halobias=0.3)
    plot_profile(r3d, Sigma_2h, '$\\Delta\\Sigma_{\\rm 2h}$')



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_25_0.png


Side note regarding the Einasto profile (CCL and NC backends only)
------------------------------------------------------------------

The Einasto profile is supported by both the CCL and NumCosmo backends.
In CCL, the value of the Einasto slope is not a free parameter and
depends on cosmology, redshift and halo mass. In NumCosmo, the default
value is :math:`\alpha=0.25` but can be set to any other value. This is
a source of confusion that needs to be handled. In the meantime, the
verbose option allows to print the value of :math:`\alpha` that is being
used, as follows:

.. code:: ipython3

    moo_ein = clmm.Modeling(massdef='mean', delta_mdef=200, halo_profile_model='einasto')
    moo_ein.set_cosmo(cosmo)
    moo_ein.set_concentration(4)
    moo_ein.set_mass(1.e15)
    # With the NC backend, you may set the slope to the value of your choosing 
    # moo_ein.set_einasto_alpha(0.1)
    
    r3d = np.logspace(-2, 2, 100)
    rho = moo_ein.eval_3d_density(r3d, z_cl, verbose=True)
    plot_profile(r3d, rho, '$\\rho_{\\rm 3d}$')


.. parsed-literal::

    Einasto alpha = 0.3713561546989172



.. image:: demo_theory_functionality_oo_files/demo_theory_functionality_oo_27_1.png

