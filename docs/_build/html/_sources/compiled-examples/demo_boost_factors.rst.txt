Compute boost factors
=====================

.. code:: ipython3

    import clmm
    from clmm import Cosmology
    from clmm.support import mock_data as mock
    from clmm.galaxycluster import GalaxyCluster
    import matplotlib.pyplot as plt
    import sys
    import clmm.utils as u

Make sure we know which version we’re using

.. code:: ipython3

    clmm.__version__




.. parsed-literal::

    '1.4.0'



Define cosmology object
~~~~~~~~~~~~~~~~~~~~~~~

.. code:: ipython3

    mock_cosmo = Cosmology(H0 = 70.0, Omega_dm0 = 0.27 - 0.045, Omega_b0 = 0.045, Omega_k0 = 0.0)

First, we want to generate a :math:`\Delta\Sigma` (excess surface
density) profile from mock data, to which we can apply boost factors.
The mock data is generated in the following cells.

Generate cluster object from mock data

.. code:: ipython3

    cosmo = mock_cosmo
    cluster_id = "Awesome_cluster"
    cluster_m = 1.e15
    cluster_z = 0.3
    concentration = 4
    ngals = 1000
    
    zsrc_min = cluster_z + 0.1 # we only want to draw background galaxies
    
    noisy_data_z = mock.generate_galaxy_catalog(cluster_m,
                                                cluster_z,
                                                concentration,
                                                cosmo,
                                                'chang13',
                                                zsrc_min=zsrc_min,
                                                shapenoise=0.005,
                                                photoz_sigma_unscaled=0.05, ngals=ngals)

Loading this into a CLMM cluster object centered on (0,0)

.. code:: ipython3

    cluster_ra = 0.0
    cluster_dec = 0.0
    cl = GalaxyCluster(cluster_id, cluster_ra, cluster_dec, 
                                   cluster_z, noisy_data_z)

Compute cross and tangential excess surface density for each source
galaxy

.. code:: ipython3

    _ = cl.compute_tangential_and_cross_components(
        geometry="flat", shape_component1='e1', shape_component2='e2', 
        tan_component='DeltaSigma_tan', cross_component='DeltaSigma_cross',
        add=True, cosmo=cosmo, is_deltasigma=True)


.. parsed-literal::

    /home/aguena/.local/lib/python3.9/site-packages/clmm-1.4.0-py3.9.egg/clmm/utils.py:633: UserWarning: Some source redshifts are lower than the cluster redshift. Returning Sigma_crit = np.inf for those galaxies.


Calculate the binned profile

.. code:: ipython3

    cl.make_radial_profile("kpc", cosmo=cosmo, 
                           tan_component_in='DeltaSigma_tan', cross_component_in='DeltaSigma_cross',
                           tan_component_out='DeltaSigma_tan', cross_component_out='DeltaSigma_cross',
                           table_name='DeltaSigma_profile')
    # Format columns for display
    for col in cl.DeltaSigma_profile.colnames:
        fmt = cl.DeltaSigma_profile[col].info.format
        if 'DeltaSigma' in col:
            fmt = '.2e'
        elif any(typ in col for typ in ('z', 'radius')):
            fmt = '.2f'
        cl.DeltaSigma_profile[col].info.format = fmt
    # Show
    cl.DeltaSigma_profile.show_in_notebook()




.. raw:: html

    <i>GCData length=10</i>
    <table id="table139910964029376-875422" class="table-striped table-bordered table-condensed">
    <thead><tr><th>idx</th><th>radius_min</th><th>radius</th><th>radius_max</th><th>DeltaSigma_tan</th><th>DeltaSigma_tan_err</th><th>DeltaSigma_cross</th><th>DeltaSigma_cross_err</th><th>z</th><th>z_err</th><th>n_src</th></tr></thead>
    <tr><td>0</td><td>70.01</td><td>369.60</td><td>618.24</td><td>2.30e+14</td><td>1.74e+13</td><td>-8.57e+12</td><td>5.28e+12</td><td>1.15</td><td>0.21</td><td>14</td></tr>
    <tr><td>1</td><td>618.24</td><td>934.69</td><td>1166.47</td><td>1.24e+14</td><td>3.41e+12</td><td>-4.35e+11</td><td>2.22e+12</td><td>1.34</td><td>0.12</td><td>56</td></tr>
    <tr><td>2</td><td>1166.47</td><td>1472.51</td><td>1714.70</td><td>7.73e+13</td><td>2.91e+12</td><td>1.38e+12</td><td>2.30e+12</td><td>1.29</td><td>0.08</td><td>74</td></tr>
    <tr><td>3</td><td>1714.70</td><td>2005.98</td><td>2262.93</td><td>5.91e+13</td><td>2.00e+12</td><td>1.12e+12</td><td>1.75e+12</td><td>1.27</td><td>0.07</td><td>107</td></tr>
    <tr><td>4</td><td>2262.93</td><td>2536.36</td><td>2811.16</td><td>4.22e+13</td><td>1.64e+12</td><td>1.07e+12</td><td>1.49e+12</td><td>1.16</td><td>0.06</td><td>115</td></tr>
    <tr><td>5</td><td>2811.16</td><td>3072.45</td><td>3359.39</td><td>3.69e+13</td><td>1.78e+12</td><td>2.61e+11</td><td>1.40e+12</td><td>1.37</td><td>0.07</td><td>163</td></tr>
    <tr><td>6</td><td>3359.39</td><td>3636.98</td><td>3907.62</td><td>2.98e+13</td><td>1.40e+12</td><td>-1.07e+12</td><td>1.87e+12</td><td>1.26</td><td>0.05</td><td>203</td></tr>
    <tr><td>7</td><td>3907.62</td><td>4147.39</td><td>4455.84</td><td>2.41e+13</td><td>1.51e+12</td><td>1.94e+12</td><td>1.49e+12</td><td>1.17</td><td>0.05</td><td>162</td></tr>
    <tr><td>8</td><td>4455.84</td><td>4686.97</td><td>5004.07</td><td>2.07e+13</td><td>1.75e+12</td><td>-2.25e+11</td><td>1.69e+12</td><td>1.21</td><td>0.08</td><td>72</td></tr>
    <tr><td>9</td><td>5004.07</td><td>5221.51</td><td>5552.30</td><td>1.57e+13</td><td>2.59e+12</td><td>7.02e+11</td><td>2.36e+12</td><td>1.25</td><td>0.11</td><td>34</td></tr>
    </table><style>table.dataTable {clear: both; width: auto !important; margin: 0 !important;}
    .dataTables_info, .dataTables_length, .dataTables_filter, .dataTables_paginate{
    display: inline-block; margin-right: 1em; }
    .paginate_button { margin-right: 5px; }
    </style>
    <script>
    
    var astropy_sort_num = function(a, b) {
        var a_num = parseFloat(a);
        var b_num = parseFloat(b);
    
        if (isNaN(a_num) && isNaN(b_num))
            return ((a < b) ? -1 : ((a > b) ? 1 : 0));
        else if (!isNaN(a_num) && !isNaN(b_num))
            return ((a_num < b_num) ? -1 : ((a_num > b_num) ? 1 : 0));
        else
            return isNaN(a_num) ? -1 : 1;
    }
    
    require.config({paths: {
        datatables: 'https://cdn.datatables.net/1.10.12/js/jquery.dataTables.min'
    }});
    require(["datatables"], function(){
        console.log("$('#table139910964029376-875422').dataTable()");
    
    jQuery.extend( jQuery.fn.dataTableExt.oSort, {
        "optionalnum-asc": astropy_sort_num,
        "optionalnum-desc": function (a,b) { return -astropy_sort_num(a, b); }
    });
    
        $('#table139910964029376-875422').dataTable({
            order: [],
            pageLength: 50,
            lengthMenu: [[10, 25, 50, 100, 500, 1000, -1], [10, 25, 50, 100, 500, 1000, 'All']],
            pagingType: "full_numbers",
            columnDefs: [{targets: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], type: "optionalnum"}]
        });
    });
    </script>




Plot the :math:`\Delta\Sigma` profile

.. code:: ipython3

    plt.errorbar(cl.DeltaSigma_profile['radius'], cl.DeltaSigma_profile['DeltaSigma_tan'],
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o')
    
    plt.title('DeltaSigma profile')
    plt.xlabel("Radius [kpc]")
    plt.ylabel('$\Delta\Sigma [M_\odot\; Mpc^{-2}]$')
    
    plt.show()



.. image:: demo_boost_factors_files/demo_boost_factors_16_0.png


Boost Factors
-------------

CLMM offers two boost models, the NFW boost model, and a powerlaw boost
model.

Note that ``compute_nfw_boost`` requires two parameters to be specified,
``rs`` and ``b0``, and ``compute_powerlaw_boost`` requires three
paramters, ``rs``, ``b0`` and ``alpha``. The default values are in kpc.

Details on these boost models can be found
`here <https://cluster-toolkit.readthedocs.io/en/latest/source/boostfactors.html>`__

First, we can calculate the boost factors from the two models.

.. code:: ipython3

    nfw_boost = u.compute_nfw_boost(cl.DeltaSigma_profile['radius'],rs=1000, b0=0.1)
    
    powerlaw_boost = u.compute_powerlaw_boost(cl.DeltaSigma_profile['radius'],rs=1000, b0=0.1, alpha=-1.0)

Plot the two boost factors, :math:`B(R)`

.. code:: ipython3

    plt.plot(cl.DeltaSigma_profile['radius'],nfw_boost,label='NFW boost factor')
    plt.plot(cl.DeltaSigma_profile['radius'],powerlaw_boost,label='Powerlaw boost factor')
    plt.xlabel("Radius [kpc]")
    plt.ylabel("$B(R)$")
    plt.legend()
    plt.show()



.. image:: demo_boost_factors_files/demo_boost_factors_21_0.png


The :math:`\Delta\Sigma` profiles can be corrected with the boost factor
using ``correct_sigma_with_boost_values`` or
``correct_sigma_with_boost_model``.

``correct_sigma_with_boost_values`` requires us to precompute the boost
factor, e.g. using ``compute_nfw_boost``.
``correct_sigma_with_boost_model`` simply requires us to specify the
boost model.

Note that the boost factor can be used in one of two ways.

Either the boost factor can be applied to the observed data vector to
correct for the dilution of the signal by cluster member galaxies. In
this case the amplitude of the corrected profile will increase.

Or the boost factor can be applied to the model prediction. In this case
it behaves as a dilution factor, and the resulting model prediction will
be lower than the original one.

Both scenarios will improve the agreement between the mock data and
observed data, by accounting for cluster member galaxy contamination.

In this notebook, we use the second approach, where the data is
generated using mock data that does not account for dilution until the
boost factor is applied. The corrected profiles from the mock data are
lower than the uncorrected one.

Essentially we are diluting the mock profile to mimick the effect of
contamination by cluster members.

First we will apply the boost factor with
``correct_sigma_with_boost_values``

.. code:: ipython3

    Sigma_corrected_powerlaw_boost = u.correct_sigma_with_boost_values(cl.DeltaSigma_profile['DeltaSigma_tan'],
                                                                       powerlaw_boost)
    Sigma_corrected_nfw_boost = u.correct_sigma_with_boost_values(cl.DeltaSigma_profile['DeltaSigma_tan'],
                                                                  nfw_boost)

Plot the result

.. code:: ipython3

    plt.errorbar(cl.DeltaSigma_profile['radius'], Sigma_corrected_nfw_boost,
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='$\Delta \Sigma$ / NFW boost factor')
    
    plt.errorbar(cl.DeltaSigma_profile['radius'], Sigma_corrected_powerlaw_boost,
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='$\Delta \Sigma$ / Powerlaw boost factor')
    
    plt.errorbar(cl.DeltaSigma_profile['radius'], cl.DeltaSigma_profile['DeltaSigma_tan'],
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='uncorrected $\Delta \Sigma$',color='grey')
    
    #plt.loglog()
    plt.title('DeltaSigma profile')
    plt.xlabel("Radius [kpc]")
    plt.ylabel('$\Delta\Sigma [M_\odot\; Mpc^{-2}]$')
    plt.legend()
    plt.show()



.. image:: demo_boost_factors_files/demo_boost_factors_27_0.png


Now the same again but with ``correct_sigma_with_boost_model``

.. code:: ipython3

    Sigma_corrected_powerlaw_boost = u.correct_sigma_with_boost_model(cl.DeltaSigma_profile['radius'],
                                                                       cl.DeltaSigma_profile['DeltaSigma_tan'],
                                                                       boost_model='powerlaw_boost')
    Sigma_corrected_nfw_boost = u.correct_sigma_with_boost_model(cl.DeltaSigma_profile['radius'],
                                                                  cl.DeltaSigma_profile['DeltaSigma_tan'],
                                                                  boost_model='nfw_boost')
    
    plt.errorbar(cl.DeltaSigma_profile['radius'], Sigma_corrected_nfw_boost,
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='$\Delta \Sigma$ / NFW boost factor')
    
    plt.errorbar(cl.DeltaSigma_profile['radius'], Sigma_corrected_powerlaw_boost,
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='$\Delta \Sigma$ / Powerlaw boost factor')
    
    plt.errorbar(cl.DeltaSigma_profile['radius'], cl.DeltaSigma_profile['DeltaSigma_tan'],
                 cl.DeltaSigma_profile['DeltaSigma_tan_err'], marker = 'o',label='uncorrected $\Delta \Sigma$',color='grey')
    
    #plt.loglog()
    plt.title('DeltaSigma profile')
    plt.xlabel("Radius [kpc]")
    plt.ylabel('$\Delta\Sigma [M_\odot\; Mpc^{-2}]$')
    plt.legend()
    plt.show()



.. image:: demo_boost_factors_files/demo_boost_factors_29_0.png

