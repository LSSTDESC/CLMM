Model WL Profiles
=================

Notebook for generating an example galaxy cluster model.
--------------------------------------------------------

This notebook goes through the steps to generate model data for galaxy
cluster weak lensing observables. In particular, we define a galaxy
cluster model that follows and NFW distribution and generate various
profiles for the model (mass density, convergence, shear, etc.), which
we plot. Note, a full pipeline to measure a galaxy cluster weak lensing
mass requires fitting the observed (or mock) data to a model.

--------------

**Note 1:** This notebook shows how to make this modeling using
functions, it is simpler than using an object oriented approach but can
also be slower. For the object oriented approach, see
`demo_theory_functionality_oo.ipynb <https://lsstdesc.org/CLMM/compiled-examples/demo_theory_functionality_oo.html>`__.

**Note 2:** There are many different approaches on using the redshift
information of the source. For a detailed description on it, see
`demo_theory_functionality_diff_z_types.ipynb <https://lsstdesc.org/CLMM/compiled-examples/demo_theory_functionality_diff_z_types.html>`__.

.. code:: ipython3

    import numpy as np
    import matplotlib.pyplot as plt
    %matplotlib inline

Imports specific to clmm

.. code:: ipython3

    import warnings
    warnings.filterwarnings("ignore", message='.*(!).*')
    import os
    os.environ['CLMM_MODELING_BACKEND'] = 'ccl' # here you may choose ccl, nc (NumCosmo) or ct (cluster_toolkit)
    import clmm
    import clmm.theory as m
    from clmm import Cosmology

Make sure we know which version weâ€™re using

.. code:: ipython3

    clmm.__version__




.. parsed-literal::

    '1.5.1'



Define a cosmology using astropy

.. code:: ipython3

    cosmo = Cosmology(H0 = 70.0, Omega_dm0 = 0.27 - 0.045, Omega_b0 = 0.045, Omega_k0 = 0.0)

Define the galaxy cluster model. Here, we choose parameters that
describe the galaxy cluster model, including the mass definition,
concentration, and mass distribution. For the mass distribution, we
choose a distribution that follows an NFW profile.

.. code:: ipython3

    #cluster properties
    density_profile_parametrization = 'nfw'
    mass_Delta = 200
    cluster_mass = 1.e15
    cluster_concentration = 4
    z_cl = 1.
    
    #source properties
    z_source = 2. #all sources in the same plan
    z_distrib_func = clmm.z_distributions.chang2013 #sources redshift following a distribution
    alpha = [2, -0.5] 

Quick test of all theory functionality

.. code:: ipython3

    r3d = np.logspace(-2, 2, 100)

.. code:: ipython3

    rho = m.compute_3d_density(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                           z_cl=z_cl, cosmo=cosmo)

.. code:: ipython3

    Sigma = m.compute_surface_density(r3d, cluster_mass, cluster_concentration, z_cl, cosmo=cosmo, 
                                      delta_mdef=mass_Delta, 
                                      halo_profile_model=density_profile_parametrization)

.. code:: ipython3

    DeltaSigma = m.compute_excess_surface_density(r3d, cluster_mass, cluster_concentration, z_cl, cosmo=cosmo, 
                                                  delta_mdef=mass_Delta, 
                                                  halo_profile_model=density_profile_parametrization)

.. code:: ipython3

    Sigmac = m.compute_critical_surface_density(cosmo, z_cluster=z_cl, z_source=z_source)

.. code:: ipython3

    gammat = m.compute_tangential_shear(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, z_cluster=z_cl, 
                                        z_source=z_source, cosmo=cosmo, delta_mdef=mass_Delta, 
                                        halo_profile_model=density_profile_parametrization, 
                                        z_src_info='discrete')

.. code:: ipython3

    kappa = m.compute_convergence(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                                   z_cluster=z_cl, z_source=z_source,
                                   cosmo=cosmo, delta_mdef=mass_Delta, 
                                   halo_profile_model=density_profile_parametrization, 
                                   z_src_info='discrete')

.. code:: ipython3

    gt = m.compute_reduced_tangential_shear(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                                            z_cluster=z_cl, z_source=z_source, cosmo=cosmo, 
                                            delta_mdef=mass_Delta, 
                                            halo_profile_model=density_profile_parametrization, 
                                            z_src_info='discrete')

.. code:: ipython3

    mu = m.compute_magnification(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                                            z_cluster=z_cl, z_source=z_source, cosmo=cosmo, 
                                            delta_mdef=mass_Delta, 
                                            halo_profile_model=density_profile_parametrization, 
                                            z_src_info='discrete')

.. code:: ipython3

    mu_bias = m.compute_magnification_bias(r3d, alpha=alpha, mdelta=cluster_mass, cdelta=cluster_concentration, 
                                            z_cluster=z_cl, z_source=z_source, cosmo=cosmo, 
                                            delta_mdef=mass_Delta, 
                                            halo_profile_model=density_profile_parametrization, 
                                            z_src_info='discrete')



.. parsed-literal::

    /global/homes/a/aguena/.local/cori/3.9-anaconda-2021.11/lib/python3.11/site-packages/clmm-1.5.1-py3.11.egg/clmm/theory/generic.py:72: UserWarning: Magnification is negative for certain radii,                     returning nan for magnification bias in this case.
    /global/homes/a/aguena/.local/cori/3.9-anaconda-2021.11/lib/python3.11/site-packages/clmm-1.5.1-py3.11.egg/clmm/theory/generic.py:74: RuntimeWarning: invalid value encountered in power


Lensing quantities assuming sources follow a given redshift
distribution.

.. code:: ipython3

    gt_z = m.compute_reduced_tangential_shear(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                                            z_cluster=z_cl, z_source=z_distrib_func, cosmo=cosmo, 
                                            delta_mdef=mass_Delta, 
                                            halo_profile_model=density_profile_parametrization,
                                            z_src_info='distribution',
                                            approx='order2')

Plot the predicted profiles

.. code:: ipython3

    def plot_profile(r, profile_vals, profile_label='rho', label = ''):
        plt.loglog(r, profile_vals, label=label)
        plt.xlabel('r [Mpc]', fontsize='xx-large')
        plt.ylabel(profile_label, fontsize='xx-large')

.. code:: ipython3

    plot_profile(r3d, rho, '$\\rho_{\\rm 3d}$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_26_0.png


.. code:: ipython3

    plot_profile(r3d, Sigma, '$\\Sigma_{\\rm 2d}$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_27_0.png


.. code:: ipython3

    plot_profile(r3d, DeltaSigma, '$\\Delta\\Sigma_{\\rm 2d}$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_28_0.png


.. code:: ipython3

    plot_profile(r3d, kappa, '$\\kappa$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_29_0.png


.. code:: ipython3

    plot_profile(r3d, gammat, '$\\gamma_t$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_30_0.png


.. code:: ipython3

    plot_profile(r3d, gt, '$g_t$', label = 'single plane')
    plot_profile(r3d, gt_z, '$g_t$', label = 'redshift distribution')
    plt.legend()





.. parsed-literal::

    <matplotlib.legend.Legend at 0x15531d17d150>




.. image:: demo_theory_functionality_files/demo_theory_functionality_31_1.png


.. code:: ipython3

    plot_profile(r3d, mu, '$\mu$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_32_0.png


.. code:: ipython3

    plot_profile(r3d, mu_bias[0]-1, profile_label = '$\delta_{\mu}$', label = '$\\alpha$ =' + str(alpha[0]))
    plot_profile(r3d, mu_bias[1]-1, '$\delta_{\mu}$', label = '$\\alpha$ =' + str(alpha[1]))
    
    plt.legend(fontsize='xx-large')
    plt.yscale('linear')
    plt.grid()
    
    plt.ylim(-3,5)




.. parsed-literal::

    (-3.0, 5.0)




.. image:: demo_theory_functionality_files/demo_theory_functionality_33_1.png


.. code:: ipython3

    # The 2-halo term excess surface density is only implemented for the CCL and NC backends
    # An error will be raised if using the CT backend instead
    
    DeltaSigma_2h = m.compute_excess_surface_density_2h(r3d, z_cl, cosmo=cosmo, halobias=0.3)
    plot_profile(r3d, DeltaSigma_2h, '$\\Delta\\Sigma_{\\rm 2h}$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_34_0.png


.. code:: ipython3

    # The 2-halo term excess surface density is only implemented for the CCL and NC backends
    # An error will be raised if using the CT backend instead
    
    Sigma_2h = m.compute_surface_density_2h(r3d, z_cl, cosmo=cosmo, halobias=0.3)
    plot_profile(r3d, Sigma_2h, '$\\Sigma_{\\rm 2h}$')



.. image:: demo_theory_functionality_files/demo_theory_functionality_35_0.png


Side note regarding the Einasto profile (CCL and NC backends only)
------------------------------------------------------------------

The Einasto profile is supported by both the CCL and NumCosmo backends.
In CCL, the value of the Einasto slope is not a free parameter and
depends on cosmology, redshift and halo mass. In NumCosmo, the default
value is :math:`\alpha=0.25` but can be set to any other value. This is
a source of confusion that needs to be handled. In the meantime, the
verbose option allows to print the value of :math:`\alpha` that is being
used, as follows:

.. code:: ipython3

    rho = m.compute_3d_density(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
                               z_cl=z_cl, cosmo=cosmo, halo_profile_model='einasto', 
                               verbose=True)
    
    # With the NC backend, you may set the slope of the Einasto profile to the value of your choosing 
    # rho = m.compute_3d_density(r3d, mdelta=cluster_mass, cdelta=cluster_concentration, 
    #                            z_cl=z_cl, cosmo=cosmo, halo_profile_model='einasto', alpha_ein=0.1, 
    #                            verbose=True)
    
    
    plot_profile(r3d, rho, '$\\rho_{\\rm 3d}$')



.. parsed-literal::

    Einasto alpha = 0.3713561546989172



.. image:: demo_theory_functionality_files/demo_theory_functionality_37_1.png

